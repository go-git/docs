{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"go-git Documentation go-git is a highly extensible Git implementation in pure Go. This documentation will help you understand and use go-git effectively in your projects. Warning: This documentation targets the v6 version of go-git. APIs are subject to change until v6 is officially released. Quick Start import ( \"github.com/go-git/go-git/v6\" ) func main () { // Clone repository repo , err := git . PlainClone ( \"/path/to/repo\" , & git . CloneOptions { URL : \"https://github.com/go-git/go-git\" , }) } Basic Concepts For a detailed explanation of go-git's architecture, please refer to our Architecture document .","title":"Home"},{"location":"#go-git-documentation","text":"go-git is a highly extensible Git implementation in pure Go. This documentation will help you understand and use go-git effectively in your projects. Warning: This documentation targets the v6 version of go-git. APIs are subject to change until v6 is officially released.","title":"go-git Documentation"},{"location":"#quick-start","text":"import ( \"github.com/go-git/go-git/v6\" ) func main () { // Clone repository repo , err := git . PlainClone ( \"/path/to/repo\" , & git . CloneOptions { URL : \"https://github.com/go-git/go-git\" , }) }","title":"Quick Start"},{"location":"#basic-concepts","text":"For a detailed explanation of go-git's architecture, please refer to our Architecture document .","title":"Basic Concepts"},{"location":"concepts/overview/","text":"Concepts go-git was built in a highly extensible manner, which enables some of its functionalities to be changed or extended without the need of changing its codebase. Here are key concepts that enable that extensibility: Dot Git Storers Dot git storers are the components responsible for storing the Git internal files, including objects and references. The built-in storer implementations include memory and filesystem . The memory storer stores all the data in memory, and its use look like this: r , err := git . Init ( memory . NewStorage (), nil ) The filesystem storer stores the data in the OS filesystem, and can be used as follows: r , err := git . Init ( filesystem . NewStorage ( osfs . New ( \"/tmp/foo\" )), nil ) New implementations can be created by implementing the storage.Storer interface . Filesystem Git repository worktrees are managed using a filesystem abstraction based on go-billy . The Git operations will take place against the specific filesystem implementation. Initialising a repository in Memory can be done as follows: fs := memfs . New () r , err := git . Init ( memory . NewStorage (), fs ) The same operation can be done against the OS filesystem: fs := osfs . New ( \"/tmp/foo\" ) r , err := git . Init ( memory . NewStorage (), fs ) New filesystems (e.g. cloud based storage) could be created by implementing go-billy 's Filesystem interface . Transport Schemes Git supports various transport schemes, including http , https , ssh , git , file . go-git defines the transport.Transport interface to represent them. The built-in implementations can be replaced by calling transport.Register . An example of changing the built-in https implementation to skip TLS could look like this: customClient := & http . Client { Transport : & http . Transport { TLSClientConfig : & tls . Config { InsecureSkipVerify : true }, }, } transport . Register ( \"https\" , githttp . NewClient ( customClient )) Some internal implementations enables code reuse amongst the different transport implementations. Some of these may be made public in the future (e.g. plumbing/transport/internal/common ). Cache Several different operations across go-git lean on caching of objects in order to achieve optimal performance. The caching functionality is defined by the cache.Object interface . Two built-in implementations are cache.ObjectLRU and cache.BufferLRU . However, the caching functionality can be customized by implementing the interface cache.Object interface. Hash go-git uses the crypto.Hash interface to represent hash functions. The built-in implementations are github.com/pjbgf/sha1cd for SHA1 and Go's crypto/SHA256 . The default hash functions can be changed by calling hash.RegisterHash . func init () { hash . RegisterHash ( crypto . SHA1 , sha1 . New ) } New SHA1 or SHA256 hash functions that implement the hash.RegisterHash interface can be registered by calling RegisterHash .","title":"Overview"},{"location":"concepts/overview/#concepts","text":"go-git was built in a highly extensible manner, which enables some of its functionalities to be changed or extended without the need of changing its codebase. Here are key concepts that enable that extensibility:","title":"Concepts"},{"location":"concepts/overview/#dot-git-storers","text":"Dot git storers are the components responsible for storing the Git internal files, including objects and references. The built-in storer implementations include memory and filesystem . The memory storer stores all the data in memory, and its use look like this: r , err := git . Init ( memory . NewStorage (), nil ) The filesystem storer stores the data in the OS filesystem, and can be used as follows: r , err := git . Init ( filesystem . NewStorage ( osfs . New ( \"/tmp/foo\" )), nil ) New implementations can be created by implementing the storage.Storer interface .","title":"Dot Git Storers"},{"location":"concepts/overview/#filesystem","text":"Git repository worktrees are managed using a filesystem abstraction based on go-billy . The Git operations will take place against the specific filesystem implementation. Initialising a repository in Memory can be done as follows: fs := memfs . New () r , err := git . Init ( memory . NewStorage (), fs ) The same operation can be done against the OS filesystem: fs := osfs . New ( \"/tmp/foo\" ) r , err := git . Init ( memory . NewStorage (), fs ) New filesystems (e.g. cloud based storage) could be created by implementing go-billy 's Filesystem interface .","title":"Filesystem"},{"location":"concepts/overview/#transport-schemes","text":"Git supports various transport schemes, including http , https , ssh , git , file . go-git defines the transport.Transport interface to represent them. The built-in implementations can be replaced by calling transport.Register . An example of changing the built-in https implementation to skip TLS could look like this: customClient := & http . Client { Transport : & http . Transport { TLSClientConfig : & tls . Config { InsecureSkipVerify : true }, }, } transport . Register ( \"https\" , githttp . NewClient ( customClient )) Some internal implementations enables code reuse amongst the different transport implementations. Some of these may be made public in the future (e.g. plumbing/transport/internal/common ).","title":"Transport Schemes"},{"location":"concepts/overview/#cache","text":"Several different operations across go-git lean on caching of objects in order to achieve optimal performance. The caching functionality is defined by the cache.Object interface . Two built-in implementations are cache.ObjectLRU and cache.BufferLRU . However, the caching functionality can be customized by implementing the interface cache.Object interface.","title":"Cache"},{"location":"concepts/overview/#hash","text":"go-git uses the crypto.Hash interface to represent hash functions. The built-in implementations are github.com/pjbgf/sha1cd for SHA1 and Go's crypto/SHA256 . The default hash functions can be changed by calling hash.RegisterHash . func init () { hash . RegisterHash ( crypto . SHA1 , sha1 . New ) } New SHA1 or SHA256 hash functions that implement the hash.RegisterHash interface can be registered by calling RegisterHash .","title":"Hash"},{"location":"tutorials/advanced-usage/","text":"Advanced Usage of go-git This guide covers advanced usage patterns and performance considerations when working with go-git. Performance Optimizations When working with large repositories or performing intensive operations, consider the following performance tips: Reduce the amount of data being cloned Shallow clones with setting depth to 1. Use Sparse Checkout for only representing part of the repository tree in the Worktree. When no tags are required, use git.NoTags . This will skip the cloning of tags, and all the objects they point to - which may result in a significant increase in cloned data. Storage Optimization The fastest storage is the memory storage. For very large repositories make sure there is enough memory available. Used in conjunction with the filter option can lead to super efficient operations. SHA1 By default, go-git uses github.com/pjbgf/sha1cd as the SHA1 algorithm. It introduces collision detection, which results in slower performance. When only trustworthy servers are used, consider using the native SHA1 implementation with hash.RegisterHash(sha1.New()) . In-memory repositories Clone in between repositories held in memory Here's an example of using a memfs filesystem, which can be used for multiple repositories. In this case, it can also be used to clone in-between sub-memfs filesystems which in fact reside on a higher level memfs. var wg sync . WaitGroup // / // /target // /src // /go-git // /go-billy func main () { rootfs := memfs . New () target , _ := rootfs . Chroot ( \"/target\" ) src , _ := rootfs . Chroot ( \"/src\" ) master , _ := src . Chroot ( \"/go-git-master\" ) concurrency , _ := src . Chroot ( \"/go-git-concurrency\" ) wg . Add ( 2 ) // providing a thread-safe memfs enables running the below as go routines clone ( master , \"https://github.com/go-git/go-git\" , \"master\" ) clone ( concurrency , \"https://github.com/go-git/go-git\" , \"read-concurrency\" ) wg . Wait () loader := server . NewFilesystemLoader ( rootfs ) client . InstallProtocol ( \"file\" , server . NewClient ( loader )) url := \"file:///src/go-git-master\" dot , err := target . Chroot ( \".git\" ) CheckIfError ( err ) Info ( \"git clone %s\" , url ) storer := filesystem . NewStorage ( dot , cache . NewObjectLRUDefault ()) r , err := git . Clone ( storer , target , & git . CloneOptions { URL : url , }) CheckIfError ( err ) ref , err := r . Head () CheckIfError ( err ) commit , err := r . CommitObject ( ref . Hash ()) CheckIfError ( err ) fmt . Println ( commit ) url2 := \"file:///src/go-git-concurrency\" err = r . Fetch ( & git . FetchOptions { RemoteURL : url2 , RefSpecs : [] config . RefSpec { ... }, }) CheckIfError ( err ) } func clone ( fs billy . Filesystem , url , branch string ) { storer := filesystem . NewStorage ( fs , cache . NewObjectLRUDefault ()) _ , err := git . Clone ( storer , nil , & git . CloneOptions { URL : url , SingleBranch : true , ReferenceName : plumbing . NewBranchReferenceName ( branch ), }) wg . Done () CheckIfError ( err ) fmt . Printf ( \"Clone %q from %q: DONE\\n\" , branch , url ) }","title":"Advanced Usage"},{"location":"tutorials/advanced-usage/#advanced-usage-of-go-git","text":"This guide covers advanced usage patterns and performance considerations when working with go-git.","title":"Advanced Usage of go-git"},{"location":"tutorials/advanced-usage/#performance-optimizations","text":"When working with large repositories or performing intensive operations, consider the following performance tips:","title":"Performance Optimizations"},{"location":"tutorials/advanced-usage/#reduce-the-amount-of-data-being-cloned","text":"Shallow clones with setting depth to 1. Use Sparse Checkout for only representing part of the repository tree in the Worktree. When no tags are required, use git.NoTags . This will skip the cloning of tags, and all the objects they point to - which may result in a significant increase in cloned data.","title":"Reduce the amount of data being cloned"},{"location":"tutorials/advanced-usage/#storage-optimization","text":"The fastest storage is the memory storage. For very large repositories make sure there is enough memory available. Used in conjunction with the filter option can lead to super efficient operations.","title":"Storage Optimization"},{"location":"tutorials/advanced-usage/#sha1","text":"By default, go-git uses github.com/pjbgf/sha1cd as the SHA1 algorithm. It introduces collision detection, which results in slower performance. When only trustworthy servers are used, consider using the native SHA1 implementation with hash.RegisterHash(sha1.New()) .","title":"SHA1"},{"location":"tutorials/advanced-usage/#in-memory-repositories","text":"","title":"In-memory repositories"},{"location":"tutorials/advanced-usage/#clone-in-between-repositories-held-in-memory","text":"Here's an example of using a memfs filesystem, which can be used for multiple repositories. In this case, it can also be used to clone in-between sub-memfs filesystems which in fact reside on a higher level memfs. var wg sync . WaitGroup // / // /target // /src // /go-git // /go-billy func main () { rootfs := memfs . New () target , _ := rootfs . Chroot ( \"/target\" ) src , _ := rootfs . Chroot ( \"/src\" ) master , _ := src . Chroot ( \"/go-git-master\" ) concurrency , _ := src . Chroot ( \"/go-git-concurrency\" ) wg . Add ( 2 ) // providing a thread-safe memfs enables running the below as go routines clone ( master , \"https://github.com/go-git/go-git\" , \"master\" ) clone ( concurrency , \"https://github.com/go-git/go-git\" , \"read-concurrency\" ) wg . Wait () loader := server . NewFilesystemLoader ( rootfs ) client . InstallProtocol ( \"file\" , server . NewClient ( loader )) url := \"file:///src/go-git-master\" dot , err := target . Chroot ( \".git\" ) CheckIfError ( err ) Info ( \"git clone %s\" , url ) storer := filesystem . NewStorage ( dot , cache . NewObjectLRUDefault ()) r , err := git . Clone ( storer , target , & git . CloneOptions { URL : url , }) CheckIfError ( err ) ref , err := r . Head () CheckIfError ( err ) commit , err := r . CommitObject ( ref . Hash ()) CheckIfError ( err ) fmt . Println ( commit ) url2 := \"file:///src/go-git-concurrency\" err = r . Fetch ( & git . FetchOptions { RemoteURL : url2 , RefSpecs : [] config . RefSpec { ... }, }) CheckIfError ( err ) } func clone ( fs billy . Filesystem , url , branch string ) { storer := filesystem . NewStorage ( fs , cache . NewObjectLRUDefault ()) _ , err := git . Clone ( storer , nil , & git . CloneOptions { URL : url , SingleBranch : true , ReferenceName : plumbing . NewBranchReferenceName ( branch ), }) wg . Done () CheckIfError ( err ) fmt . Printf ( \"Clone %q from %q: DONE\\n\" , branch , url ) }","title":"Clone in between repositories held in memory"},{"location":"tutorials/getting-started/","text":"Getting Started with go-git This guide demonstrates common Git operations using the go-git library. The go-git repository contains many examples of how to do various operations using the latest version of go-git. Cloning a Repository The following example shows how to clone a Git repository to your local filesystem: r , err := git . PlainClone ( \"/path/to/repo\" , & git . CloneOptions { URL : \"https://github.com/go-git/go-git\" , }) In-memory operations The go-git library supports in-memory Git operations, which can be useful for faster cloning operations without touching the filesystem. Here's how to clone a repository into memory: \"With worktree\" wt := memfs . New () storer := memory . NewStorage () r , err := git . Clone ( storer , wt , & git . CloneOptions { URL : \"https://github.com/go-git/go-git\" , }) \"Bare clone\" storer := memory . NewStorage () r , err := git . Clone ( storer , nil , & git . CloneOptions { URL : \"https://github.com/go-git/go-git\" , }) For bare clones, the Worktree parameter should be set to nil .","title":"Getting Started"},{"location":"tutorials/getting-started/#getting-started-with-go-git","text":"This guide demonstrates common Git operations using the go-git library. The go-git repository contains many examples of how to do various operations using the latest version of go-git.","title":"Getting Started with go-git"},{"location":"tutorials/getting-started/#cloning-a-repository","text":"The following example shows how to clone a Git repository to your local filesystem: r , err := git . PlainClone ( \"/path/to/repo\" , & git . CloneOptions { URL : \"https://github.com/go-git/go-git\" , })","title":"Cloning a Repository"},{"location":"tutorials/getting-started/#in-memory-operations","text":"The go-git library supports in-memory Git operations, which can be useful for faster cloning operations without touching the filesystem. Here's how to clone a repository into memory:","title":"In-memory operations"},{"location":"tutorials/getting-started/#with-worktree","text":"wt := memfs . New () storer := memory . NewStorage () r , err := git . Clone ( storer , wt , & git . CloneOptions { URL : \"https://github.com/go-git/go-git\" , })","title":"\"With worktree\""},{"location":"tutorials/getting-started/#bare-clone","text":"storer := memory . NewStorage () r , err := git . Clone ( storer , nil , & git . CloneOptions { URL : \"https://github.com/go-git/go-git\" , }) For bare clones, the Worktree parameter should be set to nil .","title":"\"Bare clone\""},{"location":"tutorials/migrating-from-v5-to-v6/","text":"Migrating from v5 to v6 Warning: This documentation targets the v6 version of go-git, and it is subject to change until v6 is officially released. The v6 release of go-git brings significant changes to the API. This guide will help you migrate your code from v5 to v6. Changes to git package: The bare argument has been removed from git.PlainClone and git.PlainInit . A new field Bare has been added to git.CloneOptions and git.InitOptions to indicate whether the repository should be cloned as a bare repository. The same applies to the *Context() versions of these functions. Changes to plumbing package: plumbing.TagMode has been moved to git.TagMode . References API and Behaviour changes for v6","title":"Migrating to V6"},{"location":"tutorials/migrating-from-v5-to-v6/#migrating-from-v5-to-v6","text":"Warning: This documentation targets the v6 version of go-git, and it is subject to change until v6 is officially released. The v6 release of go-git brings significant changes to the API. This guide will help you migrate your code from v5 to v6.","title":"Migrating from v5 to v6"},{"location":"tutorials/migrating-from-v5-to-v6/#changes-to-git-package","text":"The bare argument has been removed from git.PlainClone and git.PlainInit . A new field Bare has been added to git.CloneOptions and git.InitOptions to indicate whether the repository should be cloned as a bare repository. The same applies to the *Context() versions of these functions.","title":"Changes to git package:"},{"location":"tutorials/migrating-from-v5-to-v6/#changes-to-plumbing-package","text":"plumbing.TagMode has been moved to git.TagMode .","title":"Changes to plumbing package:"},{"location":"tutorials/migrating-from-v5-to-v6/#references","text":"API and Behaviour changes for v6","title":"References"},{"location":"tutorials/troubleshooting/","text":"Troubleshooting This guide covers common issues encountered when using go-git. Debugging and Tracing Available Trace Options go-git supports different tracing levels. Enable them by calling trace.SetTarget : import `github.com/go-git/go-git/v6/utils/trace` ... trace . SetTarget ( trace . SSH | trace . Performance ) Here are the current trace options: General: General traces general operations. Packet: Packet traces git packets. SSH: SSH handshake operations. This does not have a direct translation to an upstream trace option. Performance: performance information for specific go-git operations. HTTP: HTTP operations and requests. ### SSH Connection Issues To enable trace information for SSH handshakes, use the `GIT_TRACE_SSH` environment variable: ```bash $ GIT_TRACE_SSH=true go run _examples/clone/main.go git@github.com:go-git/go-git /tmp/go-git 19:09:14.134147 common.go:43: ssh: Using default auth builder (user: git) 19:09:14.134193 sshagent.go:42: ssh: net.Dial unix sock /tmp/ssh-XXXXXXULYg1c/agent.6427 19:09:14.134224 auth_method.go:224: ssh: ssh-public-key-callback user=git 19:09:14.134317 auth_method.go:345: ssh: found key: sk-ssh-ed25519@openssh.com SHA256:otsLd7qnCx9TrhUfIPCiP2cbk3Rkb5gtxyUJy2Zeheo 19:09:14.134323 auth_method.go:255: ssh: known_hosts sources [/home/levi/.ssh/known_hosts /etc/ssh/ssh_known_hosts] 19:09:14.134330 auth_method.go:260: ssh: filtered known_hosts sources [/home/levi/.ssh/known_hosts] 19:09:14.134533 auth_method.go:255: ssh: known_hosts sources [/home/levi/.ssh/known_hosts /etc/ssh/ssh_known_hosts] 19:09:14.134540 auth_method.go:260: ssh: filtered known_hosts sources [/home/levi/.ssh/known_hosts] 19:09:14.134577 common.go:155: ssh: host key algorithms [ssh-ed25519] 19:09:14.458332 auth_method.go:330: ssh: hostkey callback hostname=github.com:22 remote=20.26.156.215:22 pubkey=\"ssh-ed25519 SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU\" Common Errors and Solutions Performance Issues Large Repository Cloning Problem: Slow clone times for large repositories Solutions: 1. Use shallow clone: _ , err := git . PlainClone ( \"/path\" , & git . CloneOptions { URL : \"https://github.com/user/repo\" , Depth : 1 , // Only fetch latest commit }) Clone single branch: _ , err := git . PlainClone ( \"/path\" , & git . CloneOptions { URL : \"https://github.com/user/repo\" , SingleBranch : true , ReferenceName : plumbing . NewBranchReferenceName ( \"main\" ), }) Skip tags when not needed: _ , err := git . PlainClone ( \"/path\" , & git . CloneOptions { URL : \"https://github.com/user/repo\" , NoTags : true , }) Getting Help If you encounter issues not covered here: Check the examples directory for usage patterns Enable tracing to get detailed debug information Review the GitHub issues for similar problems Create a minimal reproduction case when reporting bugs","title":"Troubleshooting"},{"location":"tutorials/troubleshooting/#troubleshooting","text":"This guide covers common issues encountered when using go-git.","title":"Troubleshooting"},{"location":"tutorials/troubleshooting/#debugging-and-tracing","text":"","title":"Debugging and Tracing"},{"location":"tutorials/troubleshooting/#available-trace-options","text":"go-git supports different tracing levels. Enable them by calling trace.SetTarget : import `github.com/go-git/go-git/v6/utils/trace` ... trace . SetTarget ( trace . SSH | trace . Performance ) Here are the current trace options: General: General traces general operations. Packet: Packet traces git packets. SSH: SSH handshake operations. This does not have a direct translation to an upstream trace option. Performance: performance information for specific go-git operations. HTTP: HTTP operations and requests. ### SSH Connection Issues To enable trace information for SSH handshakes, use the `GIT_TRACE_SSH` environment variable: ```bash $ GIT_TRACE_SSH=true go run _examples/clone/main.go git@github.com:go-git/go-git /tmp/go-git 19:09:14.134147 common.go:43: ssh: Using default auth builder (user: git) 19:09:14.134193 sshagent.go:42: ssh: net.Dial unix sock /tmp/ssh-XXXXXXULYg1c/agent.6427 19:09:14.134224 auth_method.go:224: ssh: ssh-public-key-callback user=git 19:09:14.134317 auth_method.go:345: ssh: found key: sk-ssh-ed25519@openssh.com SHA256:otsLd7qnCx9TrhUfIPCiP2cbk3Rkb5gtxyUJy2Zeheo 19:09:14.134323 auth_method.go:255: ssh: known_hosts sources [/home/levi/.ssh/known_hosts /etc/ssh/ssh_known_hosts] 19:09:14.134330 auth_method.go:260: ssh: filtered known_hosts sources [/home/levi/.ssh/known_hosts] 19:09:14.134533 auth_method.go:255: ssh: known_hosts sources [/home/levi/.ssh/known_hosts /etc/ssh/ssh_known_hosts] 19:09:14.134540 auth_method.go:260: ssh: filtered known_hosts sources [/home/levi/.ssh/known_hosts] 19:09:14.134577 common.go:155: ssh: host key algorithms [ssh-ed25519] 19:09:14.458332 auth_method.go:330: ssh: hostkey callback hostname=github.com:22 remote=20.26.156.215:22 pubkey=\"ssh-ed25519 SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU\"","title":"Available Trace Options"},{"location":"tutorials/troubleshooting/#common-errors-and-solutions","text":"","title":"Common Errors and Solutions"},{"location":"tutorials/troubleshooting/#performance-issues","text":"","title":"Performance Issues"},{"location":"tutorials/troubleshooting/#large-repository-cloning","text":"Problem: Slow clone times for large repositories Solutions: 1. Use shallow clone: _ , err := git . PlainClone ( \"/path\" , & git . CloneOptions { URL : \"https://github.com/user/repo\" , Depth : 1 , // Only fetch latest commit }) Clone single branch: _ , err := git . PlainClone ( \"/path\" , & git . CloneOptions { URL : \"https://github.com/user/repo\" , SingleBranch : true , ReferenceName : plumbing . NewBranchReferenceName ( \"main\" ), }) Skip tags when not needed: _ , err := git . PlainClone ( \"/path\" , & git . CloneOptions { URL : \"https://github.com/user/repo\" , NoTags : true , })","title":"Large Repository Cloning"},{"location":"tutorials/troubleshooting/#getting-help","text":"If you encounter issues not covered here: Check the examples directory for usage patterns Enable tracing to get detailed debug information Review the GitHub issues for similar problems Create a minimal reproduction case when reporting bugs","title":"Getting Help"}]}